---
title: 20.专项强化-管综（数学）第5章 数列-模块2等差数列（上）
lang: zh-CN
---


# 模块 5-02 等差数列  

## 1.定义  
如果在数列`{a_n}`中，a_(n+1)-a_n=d(常数)(n∈N₊)，则称数列`{a_n}`为等差数列，d为公差.        
`a_(n+1)-a_n=d`定义规则：根据递推式定义，即n+1，n        
本质：差值为常数   
1，4，7，10，13  
=> 差值都为3，差值是固定的，这种就称为等差数列       


## 2.通项a_n(即每个元素满足一个共有的表达式)      
`a_n=a_1+(n-1)d=a_k+(n-k)d=nd+a_1-d`      
评注：若已知两个元素，要会求公差`d=(a_n-a_m)/(n-m)`   

1. a_n=a_1+(n-1)d (`须知道a_1的值未知则不能使用`)    
   1. 推导过程(根据定义`a_(n+1)-a_n=d`推理)：     
      a_(n+1)-a_n=d    
      => [a=1: a_2-a_1=d, a=2: a_3-a_2=d, a=3: a_4-a_3=d, ..., a_n-a_(n-1)=d]      
      数列相加    
      这里的每一项的前项跟下一项的后项`a_2-a_2，a_3-a_3`可以相互抵消     
      `d`为每一项的间距值即`(n-1)d`就可以确认数列中有几个间距即每一项之间的公差           
      => [a_2-a_1=d, a_3-a_2=d, a_4-a_3=d, ..., a_n-a_(n-1)=d] `= a_n-a_1=(n-1)d`       
      => a_n-a_1=(n-1)d      
      移项     
      => an=a_1+(n-1)d    
   2. 示例：例如当前为a_5  
      代入`a_n=a_1+(n-1)d`公式   
      a_5=a_1+(5-1)d
      => a_1+4d     
2. a_n=a_k+(n-k)d (`重点公式：这个公式比较灵活已知任意一个a_n(例如a_3，a_7，a_1不是必要条件)都可以求出a_n的值`)      
   1. 示例：例如当前已知a_3，求a_5     
      代入`a_n=a_k+(n-k)d`公式  
      1. a_n = a_5
      2. a_k = a_3     

      a_5=a_3+(5-3)d   
      => a_3+2d   
3. a_n=nd+a_1-d (`将a_1+(n-1)d展开进行整理，目标把n即(x)看作一个一元一次函数`)       
   1. 推导过程：      
      a_1+(n-1)d    
      => a_1+(n·d)+(-1·d)     
      => a_1+nd-d  
      => nd+a_1-d
   2. 把`nd+a_1-d`看作一次f(x)函数：        
      1. a_n可以看作为y    
      2. n可以看作为x   
      3. y=x·d+a_1-d    
         等差数列通项特征是关于x的自变量一次函数，n=x       
         `系数：系数是与变量相乘的数字`   
         n(x)的系数就是公差d，即`x·d`，
         例如：a_n=4n-3     
         => d=4 即 nd=4n     
         => a1=4-3=1

4. 评注`d=(a_n-a_m)/(n-m)`    
   1. 推导过程：    
      由`a_n=a_k+(n-k)d`进行变形得来      
      a_n=a_k+(n-k)d    
      移项     
      => a_n-a_k=(n-k)d    
      提取`a_n-a_k`,`(n-k)`进行相除即可得到d公差的值  
      这里的`m=k`   
      => d=(a_n-a_k)/(n-k)      
   2. 示例   
      n=9   
      k=4  
      d=(a_9-a_4)/(9-4)


## 3. 前n项和S_n   
`S_n=((a_1+a_n)/2)·n=na_1+((n(n-1))/2)d=d/2·n^2+(a_1-(d/2))n`       

1. S_n=((a_1+a_n)/2)·n(`已知（a_1，a_n，n）的值可用此公式`)   
   1. 推导过程：   
      S_n=a_1+a_2+...+a_n   
      首尾配对：a_1配a_n，a_2配a_(n-1)     
      原理：例如`1+2+...+100`  
      首尾配对相加后结果都是一样的   
      => 1+100=101   
      => 2+99=101  
      `即高斯求和公式可以之间得出结果：S_n=(n(n+1))/2`    
      => 1+2+...+100 = ((100+1)/2)·100    
      => ((100+1)/2)·100 = 5050   

2. S_n=na_1+(n(n-1)/2)d (`已知（d，na_1，n）的值可用此公式`)      
   1. 推导过程(由`((a_1+a_n)/2)·n`变形得来)：     
      ((a_1+a_n)/2)·n    
      `将a_n看作2.通项a_n的第一个公式`       
      => a_n=a_1+(n-1)d      
      代入     
      => ((a_1+(a_1+(n-1)d))/2)·n      
      合并括号内的项      
      => ((2a_1+(n-1)d)/2)·n     
      分配n到每一项    
      => ((2a_1·n)/2)+(((n-1)d)·n/2)          
      对第一项的分子跟分母2进行约分      
      => (2a_1·n)/2 = a_1·n
      => a_1·n+(((n-1)d)·n/2)    
      => na_1+(n(n-1)/2)d 

3. S_n=(d/2)·n^2+(a_1-(d/2))n (`将na_1+(n(n-1)/2)d展开进行整理，目标把n即(x)看作一个一元二次函数`)  
   1. 推导过程(由`na_1+(n(n-1)/2)d`变形得来)：     
      na_1+(n(n-1)/2)d    
      展开第二项    
      => (n(n-1)/2)d = (n^2-n/2)·d    
      将`(n^2-n/2)·d`d分配到括号内的每一项     
      => ((d/2)·n^2)-((d/2)·n)      
      将两项合并        
      => na_1+((d/2)·n^2)-((d/2)·n)      
      `然后将na_1和-((d/2)·n)结合成一项`     
      => [na_1, -((d/2)·n)] = (a_1-(d/2))n      
      => ((d/2)·n^2)+(a_1-(d/2))n   
      => (d/2)·n^2+(a_1-(d/2))n
   2. 把`(d/2)·n^2+(a_1-(d/2))n`看作二次f(x)函数：   
      1. (n,x)`(d/2)·n^2`可以看作为y        
      2. n^2可以看作为x^2     
      3. y=(d/2)·x^2+(a_1-(d/2))x         
         即为抛物线函数       
         x^2的系数`d/2`即为公差的一半     
         一元二次公式: `ax^2+bx+c`     
         例如：`S_n=3n^2-5n`     
         a=3            
         b=-5     
         c=0 `(不能有常数项，必须为0)`    
         即`d/2`为`3`即一半           
         => d=3·2           
         => d=6   
         求a_1值：`a_1=S_1`       
         代入`S_n=3n^2-5n`    
         => S_1=3·1^2-5·1  
         => 3-5   
         => a_1=S_1=-2   
         `注意`: 如果后面加常数项`ç`这个就不是等差数列S_n，
         因为常数项会影响首项即`a_1`会发生变化，`a_1`不在保持等差关系[详细参考: 题目［例4］](/math/3.%E6%95%B0%E5%AD%A6-%E4%B8%93%E9%A2%98%E5%BC%BA%E5%8C%96%E8%AF%BE/19.%E4%B8%93%E9%A1%B9%E5%BC%BA%E5%8C%96-%E7%AE%A1%E7%BB%BC%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E5%88%97-%E6%A8%A1%E5%9D%971%E6%95%B0%E5%88%97%E5%AE%9A%E4%B9%89.html#%E4%B9%A0%E9%A2%98)       
         

## 4.重要性质   

1. 若m+n=k+t，则a_m+a_n=a_k+a_t **(重点)**   
   a_3+a_9=a_5+a_7    
   a_3跟a_5之间的间距是2个d      
   a_9跟a_7之间的间距是2个d   
   这样即等式的两边扯平了   
   `注意`不能写成 `a_3+a_9=a_12` 需要保持序号跟a的个数一致但是可以写成`2a_6`即`2个a_6`字母个数跟下角标之和一致              

2. S_n为等差数列前n项和，则S_n,S_2n,-S_n,S_3n,-S_2n,...仍是等差数列(即分段求和)，公差为(n^2)d   
   1. 示例   
      a_1，a_2，a_3，a_4，a_5，a_6，a_7，a_8，a_9，a_10    
      分成每3个元素作为一个组    
      然后分组进行求和     
      `注意`每个组的数量需要一致(即一个组3个或者4个或者其他需要保持一致) 
      1. a_1，a_2，a_3       
         = S_3    
      2. a_4，a_5，a_6    
         = (S_6)-(S_3)   
      3. a_7，a_8，a_9   
         = (S_9)-(S_6)  
      
      验证是否示等差数列：   
      1. 第2组   
         (a_4+a_5+a_6)-(a_1+a_2+a_3)    
         => a_4-a_1 = 3d    
         => a_5-a_2 = 3d   
         => a_6-a_3 = 3d   
         => 3·3d   
         => (3^2)d   
         即每个元素之间的差保持相同数量一致的公差(常数)，即公差为`(n^2)d`   
      2. 第3组跟第2组一样元素之间的差也保持相同数量(即3个d)

3. 等差数列{a_n}和{b_n}的前n项和分别用S_n，T_n表示，则(a_k/b_k)=(S_(2k-1)/T_(2k-1))      
   即两个数列前n项使用`(a_k/b_k)=(S_(2k-1)/T_(2k-1))`公式表示      
   1. 等差数列对称性质    
      在等差数列中，首尾对称的项之和等于中间项的两倍    
      公式：`i+j=2k`  i或j即为首尾项    
      1. 示例（等于中间项的两倍）     
         2, 5, 8, 11, 14   
         这是一个首项为2，公差为3的等差数列，这个数列有5项    
         在这个数列中，对称项对可以是：    
         第1项和第5项    
         => 2+14=16     
         第2项和第4项    
         => 5+11=16   
         中间项是第3项,中间项的两倍也是16       
         => 8·2=16   
         即对称项之和等于中间项的两倍(或等于中间项的和)   
         奇数项数列：对称项之和等于`中间项的两倍`    
         偶数项数列：对称项之和等于`两个中间项的和`  

   2. 推导验证   
      (S_(2k-1)/T_(2k-1))   
      [前n项和S_n公式1: S_n=((a_1+a_n)/2)·n](/math/3.%E6%95%B0%E5%AD%A6-%E4%B8%93%E9%A2%98%E5%BC%BA%E5%8C%96%E8%AF%BE/20.%E4%B8%93%E9%A1%B9%E5%BC%BA%E5%8C%96-%E7%AE%A1%E7%BB%BC%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89%E7%AC%AC5%E7%AB%A0%20%E6%95%B0%E5%88%97-%E6%A8%A1%E5%9D%972%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%EF%BC%88%E4%B8%8A%EF%BC%89.html#_3-%E5%89%8Dn%E9%A1%B9%E5%92%8Cs-n)      
      n=(2k-1)代入`S_n=((a_1+a_n)/2)·n`      
      => (((a_1+a_(2k-1))/2)·2k-1)/(((b_1+b_(2k-1))/2)·2k-1)    
      根据`1. 等差数列对称性质` 首尾对称的项之和等于中间项的两倍        
      => a_1+a_(2k-1)   
      => a_1+a_1k    
      即`i+j=2k`2k为对称项之和        
      => a_2k   
      `a_k`为中间项    
      => 2a_k    
      代入分子`2a_k`，b也是一样的换成`2b_k`   
      => (((2a_k)/2)·2k-1)/(((2b_k)/2)·2k-1)   
      约分分子跟分母`2`相互约掉      
      => ((a_k)·2k-1)/((b_k)·2k-1)    
      约分分子跟分母`2k-1`相互约掉   
      => (a_k)/(b_k)    
      **这样即把两个数列的求和比跟元素比关联在了一起**    
   









